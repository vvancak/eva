package evolution;

import evolution.individuals.Individual;
import evolution.operators.Operator;
import evolution.selectors.Selector;

import java.util.ArrayList;

/**
 * The main class which is responsible for the run of a single generation of
 * the evolutionary algorithm. Provides a way to specify the fitness function,
 * operators, and selectors used during the evolution. Also the size of the
 * elite can be specified.
 *
 * @author Martin Pilat
 */
public class EvolutionaryAlgorithm {

    ArrayList<Operator> operators;
    ArrayList<Selector> matingSelectors;
    ArrayList<Selector> environmentalSelectors;
    double eliteSize = 0.05;
    FitnessEvaluator fitness;
    Replacement replacement;
    int generationNo = 0;

    /**
     * Initializes an empty evolutionary algorithm. Replacement is set to the
     * instance of SGAReplacement. All other values remain unset.
     */
    public EvolutionaryAlgorithm() {
        operators = new ArrayList<Operator>();
        matingSelectors = new ArrayList<Selector>();
        environmentalSelectors = new ArrayList<Selector>();
        replacement = new SGAReplacement();
    }

    /**
     * Setter for the replacement.
     *
     * @param replacement The replacement which shall be used.
     */
    public void setReplacement(Replacement replacement) {
        this.replacement = replacement;
    }

    /**
     * Specifies the size of the elite which shall be used.
     *
     * @param elitePercentage The percentage of population which shall be used as
     *                        elite. Should be number between 0.0 and 1.0 (inclusive).
     */
    public void setElite(double elitePercentage) {
        eliteSize = elitePercentage;
    }

    /**
     * Adds a new genetic operator to the queue of genetic operators.
     *
     * @param o The operator which should be added.
     */
    public void addOperator(Operator o) {
        operators.add(o);
    }

    /**
     * Adds a new mating selector the the queue of mating selectors.
     *
     * @param s The selector which shall be added.
     */

    public void addMatingSelector(Selector s) {
        matingSelectors.add(s);
    }

    /**
     * Adds a new environmental sector to the queue of environmental selectors.
     *
     * @param s The environmental selector which shall be added.
     */
    public void addEnvironmentalSelector(Selector s) {
        environmentalSelectors.add(s);
    }

    /**
     * Sets the fitness function which is maximized by the evolutionary algoritm.
     * <p/>
     * Internally this method creates an instance of SimpleEvaluater which is used
     * the evaluate the whole population.
     *
     * @param f The fitness function which shall be used.
     */
    public void setFitnessFunction(FitnessFunction f) {
        fitness = new SimpleEvaluator(f);
    }

    /**
     * Sets the fitness evaluator which evaluates the whole population at once. This allows
     * to assign fitness to individuals even if the fitness of particular individual
     * depends on the fitness of other individuals in the population.
     *
     * @param fe The fitness evaluator which shall be used. Must assign fitness to all
     *           individuals in the population.
     */

    public void setFitnessEvaluator(FitnessEvaluator fe) {
        fitness = fe;
    }

    /**
     * Executes one generation of the evolutionary algorithm.
     * <p/>
     * First, the mating selectors are used to create the mating pool. In this
     * step, if there are n mating selectors, each of them selects 1/n of the
     * population. The last specified selector may select more individuals to make
     * the population size constant.
     * <p/>
     * Next, the specified operators are executed in the order they were specified.
     * The population generated by an operator is used as the input for the next
     * operator in the queue.
     * <p/>
     * Then, the selection starts. First, the specified number of elite individuals
     * is added to the population of selected individuals. Then the parent and
     * offspring populations are combined using the replacement specified and
     * environmental selections are executed to select individuals from the combined
     * population. The process is similar to the one used for mating selectors.
     * <p/>
     * Finally, the individuals in the input population are replaced by the newly
     * selected individuals.
     *
     * @param pop The population on which the single generation shall be run.
     */

    public void evolve(Population pop) {

        if (fitness == null)
            throw new RuntimeException("No fitness function defined");

        generationNo++;

        fitness.evaluate(pop);

        if (generationNo == 1) {
            DetailsLogger.logInitialPopulation(pop);
        }

        DetailsLogger.logNewGeneration(generationNo);
        DetailsLogger.logNewMatingSelection();

        Population parents = pop;

        Population matingPool = new Population();

        if (matingSelectors.size() > 0) {
            int mateSel = matingSelectors.size();
            int toSelect = parents.getPopulationSize() / mateSel;
            for (int i = 0; i < matingSelectors.size(); i++) {
                Population sel = new Population();
                matingSelectors.get(i).select(toSelect, parents, sel);
                matingPool.addAll((Population) sel.clone());
                for (int j = matingPool.getPopulationSize() - toSelect; j < matingPool.getPopulationSize(); j++) {
                    matingPool.get(j).setLogNotes(matingSelectors.get(i).getClass().getCanonicalName());
                }
            }

            int missing = parents.getPopulationSize() - matingPool.getPopulationSize();
            if (missing > 0) {
                Population sel = new Population();
                matingSelectors.get(matingSelectors.size() - 1).select(missing, parents, sel);
                matingPool.addAll((Population) sel.clone());
                for (int i = matingPool.getPopulationSize() - missing; i < matingPool.getPopulationSize(); i++) {
                    matingPool.get(i).setLogNotes(matingSelectors.get(matingSelectors.size() - 1).getClass().getCanonicalName());
                }
            }
        } else {
            matingPool = (Population) parents.clone();
            matingPool.shuffle();
            for (int i = 0; i < matingPool.getPopulationSize(); i++) {
                matingPool.get(i).setLogNotes("none:shuffle");
            }
        }

        DetailsLogger.logSelectedPart(parents);

        if (DetailsLogger.isEnabled()) {
            fitness.evaluate(matingPool); //just for logging
            DetailsLogger.logMatingPool(matingPool);
        }

        Population offspring = null;
        for (Operator o : operators) {
            DetailsLogger.logNewOperator(o.getClass().getCanonicalName());
            offspring = new Population();
            o.operate(matingPool, offspring);
            if (DetailsLogger.isEnabled()) {
                fitness.evaluate(offspring); //just for logging
                DetailsLogger.logOffspring(offspring);
            }
            matingPool = offspring;
        }

        fitness.evaluate(offspring);

        Population selected = new Population();

        DetailsLogger.logNewEnvironmentalSelection();

        Population combined = replacement.replace(parents, offspring);

        if (environmentalSelectors.isEmpty()) {
            selected = (Population)combined.clone();
            fitness.evaluate(combined);
        } else {
            ArrayList<Individual> sortedOld = parents.getSortedIndividuals();
            for (int i = 0; i < eliteSize * parents.getPopulationSize(); i++) {
                selected.add(sortedOld.get(i));
                sortedOld.get(i).setLogNotes(sortedOld.get(i).getLogNotes() + " none:elitism");
            }


            fitness.evaluate(combined);

            int envSel = environmentalSelectors.size();
            int toSelect = (parents.getPopulationSize() - selected.getPopulationSize()) / envSel;
            for (int i = 0; i < environmentalSelectors.size(); i++) {
                Population sel = new Population();
                environmentalSelectors.get(i).select(toSelect, combined, sel);
                selected.addAll((Population) sel.clone());
            }

            int missing = parents.getPopulationSize() - selected.getPopulationSize();
            if (missing > 0) {
                Population sel = new Population();
                environmentalSelectors.get(environmentalSelectors.size() - 1).select(missing, combined, sel);
                selected.addAll((Population) sel.clone());
            }
        }

        DetailsLogger.logSelectedPart(combined);

        pop.clear();
        pop.addAll(selected);

        fitness.evaluate(pop);
    }


}
